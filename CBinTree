// Arbol Binario de Busqueda.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//

#include <iostream>
#include <cstdlib>
#include <ctime>  
#include <stack>  
#include <utility>
using namespace std;


//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////USANDO PILA//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


template <class T>
struct nodo
{
    T valor;
    nodo<T>* nodos[2];
    nodo(T valor_, nodo<T>* left = NULL, nodo<T>* right = NULL) {
        valor = valor_;
        *(nodos) = left;
        *(nodos + 1) = right;
    }
};


template <class T>
struct par
{
    T valor = 0;
    nodo<T>* pointer;
    par<T>* next;


    par(par<T>* p_ = NULL, nodo<T>* ptr = NULL)
    {
        pointer = ptr;
        next = p_;
    }
};

template <class T>
struct PILA {
    par<T>* head;

    PILA(par<T>* h = NULL)
    {
        head = h;
    }
    void push(nodo<T>* p)
    {
        if (!p) return;
        head = new par<T>(head, p);
    }

    void pop()
    {
        par<T>* tmp = head;
        head = head->next;
        delete tmp;
    }
};

template<class T>
struct CBinTree
{
    nodo<T>* root = NULL;
    PILA<T> pila;
    bool first = true;
    bool insert(T valor);
    bool remove(T valor);
    nodo<T>** rep(nodo<T>** pos);
    bool find(T valor, nodo<T>**& pos);
    void ordenar_sin_rec(nodo<T>* p);
};


template<class T>
void CBinTree<T>::ordenar_sin_rec(nodo<T>* p)
{
    pila.push(p);
    while (pila.head)
    {
        switch (pila.head->valor)
        {
        case 0:
            pila.head->valor = 1;
            p = p->nodos[0];
            pila.push(p);
            break;
        case 1:
            cout << pila.head->pointer->valor << " ";
            pila.head->valor = 2;
            break;
        case 2:
            pila.head->valor = 3;
            p = pila.head->pointer->nodos[1];
            pila.push(p);
            break;
        case 3:
            pila.pop();
            break;
        }
    }
}

template <class T>
void Inorder_DS(nodo<T>* p) {
    if (p == nullptr) {
        return;
    }

    std::stack<pair<nodo<T>*, int>> pila;
    pila.push(make_pair(p, 0));

    while (!pila.empty()) {
        auto& par = pila.top(); // Obtener una referencia al par en el tope del stack
        nodo<T>* t = par.first;
        int& value = par.second; // Crear una referencia al segundo elemento del par

        switch (value) {
        case 0:
            if (t->nodos[0] != nullptr) {
                pila.push(make_pair(t->nodos[0], 0));
            }
            value = 1;
            break;
        case 1:
            cout << t->valor << " ";
            value = 2;
            if (t->nodos[1] != nullptr) {
                pila.push(make_pair(t->nodos[1], 0));
            }
            break;
        case 2:
            pila.pop();
            break;
        }
    }
}

template<class T>
bool CBinTree<T>::insert(T valor)
{
    nodo<T>** pos;
    if (find(valor, pos)) return 0;
    if (first) { *pos = new nodo<T>(valor, root, root); first = false; }
    else
    {
        *pos = new nodo<T>(valor, (*pos), (*pos));
    }
    return 1;
}

template<class T>
bool CBinTree<T>::remove(T valor)
{
    nodo<T>** pos;
    if (!find(valor, pos)) return 0;
    //caso 2
    if ((*pos)->nodos[0] && (*pos)->nodos[1])
    {
        nodo<T>** q = rep(pos);
        (*pos)->valor = (*q)->valor;
        pos = q;
    }
    //caso 0 y 1
    nodo<T>* tmp = *pos;
    *pos = (*pos)->nodos[(*pos)->nodos[0] == 0];
    delete tmp;
    if (!root) { first = true; }
    return 1;
}

template<class T>
nodo<T>** CBinTree<T>::rep(nodo<T>** pos)
{
    nodo<T>** q;
    int b = rand() % 2;
    q = &((*pos)->nodos[b]);
    while ((*q)->nodos[!b])
        q = &((*q)->nodos[!b]);
    return q;
}
template<class T>
bool CBinTree<T>::find(T valor, nodo<T>**& pos)
{
    pos = &root;
    while (*pos && (*pos)->valor != valor)
    {
        pos = &((*pos)->nodos[valor > (*pos)->valor]);
    }
    return *pos && (*pos)->valor == valor;
}

template <class T>
void Inorder(nodo<T>* p)
{
    if (!p) return;
    Inorder(p->nodos[0]);
    cout << p->valor << " ";
    Inorder(p->nodos[1]);
}

template <class T>
void Postorder(nodo<T>* p)
{
    if (!p) return;
    Inorder(p->nodos[0]);
    Inorder(p->nodos[1]);
    cout << p->valor << " ";
}
template <class T>
void Preorder(nodo<T>* p)
{
    if (!p) return;
    cout << p->valor << " ";
    Inorder(p->nodos[0]);
    Inorder(p->nodos[1]);
}
template <class T>
void Preorder_DS(nodo<T>* p) {
    if (p == nullptr) {
        return;
    }

    std::stack<pair<nodo<T>*, int>> pila;
    pila.push(make_pair(p, 0));

    while (!pila.empty()) {
        auto& par = pila.top(); 
        nodo<T>* t = par.first;
        int& value = par.second; 

        switch (value) {
        case 0:
            cout << t->valor << " ";
            value = 1;
            if (t->nodos[0] != nullptr) {
                pila.push(make_pair(t->nodos[0], 0));
            }
            break;
        case 1:
            value = 2;
            if (t->nodos[1] != nullptr) {
                pila.push(make_pair(t->nodos[1], 0));
            }
            break;
        case 2:
            pila.pop();
            break;
        }
    }
}

template <class T>
void Postorder_DS(nodo<T>* p) {
    if (p == nullptr) {
        return;
    }

    std::stack<pair<nodo<T>*, int>> pila;
    pila.push(make_pair(p, 0));

    while (!pila.empty()) {
        auto& par = pila.top(); // Obtener una referencia al par en el tope del stack
        nodo<T>* t = par.first;
        int& value = par.second; // Crear una referencia al segundo elemento del par

        switch (value) {
        case 0:
            if (t->nodos[0] != nullptr) {
                pila.push(make_pair(t->nodos[0], 0));
            }
            value = 1;
            break;
        case 1:
            if (t->nodos[1] != nullptr) {
                pila.push(make_pair(t->nodos[1], 0));
            }
            value = 2;
            break;
        case 2:
            cout << t->valor << " ";
            pila.pop();
            break;
        }
    }
}
int main()
{
    srand(time(nullptr));

    CBinTree<int> tree;


    for (int i = 0; i < 10; ++i) {
        int valor = rand() % 100;
        cout << "INSERTANDO ->" << valor << endl;
        tree.insert(valor);
    }


    cout << "Valores del arbol binario de busqueda USANDO INORDER" << endl;

    Inorder(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO INORDER_DS_OWN_PAIR & STACK" << endl;

    tree.ordenar_sin_rec(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO INORDER_DS" << endl;

    Inorder_DS(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO POSTORDER" << endl;

    Postorder(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO POSTORDER_DS" << endl;

    Postorder_DS(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO PREORDER" << endl;

    Preorder(tree.root);

    cout << endl << "Valores del arbol binario de busqueda USANDO PREORDER_DS" << endl;

    Preorder_DS(tree.root);


    return 0;
}
